#!/bin/bash
NAME=$(basename $0)
# Depends:
# bin: bash cat sed(GNU) grep man groff
# debian: bash coreutils grep man-db groff-base
__init__() {
	local _argc=$#
	if ! ${ADS_INITILIZED:-false}; then
		. <(__init <<-_EOF_
				#NAME: ads
				#TITLE: ADS Manual
				#VERSION: 1.0
				#RESUME: Auto documented script.
				#DESCRIPTION: _ADS_ permit script using it to be self and automatically documented. This tool permit to generate code to initializing options command line and add a _help_ which generates one in the manpage format.
				#AUTHOR: Thomas Pérennou <thomas.perennou@aeten.net>
				#LICENCE: GLPv3
				#COPYLEFT: Thomas Pérennou
				@init !/doc: Initialize a shell script from _doc_. Read _doc_ A shell script must call it like _source <(${NAME} init [<args>] -- \$@ <<EOF […] EOF)_.
				 	?prefix NAME: Prefixes all generated variables by _NAME\__ (note the underscore after _NAME_).
				 	?posix: Select this option to generate POSIX shell code. Ddo not use associative array for parameters n the form of _param_=_value_.
				@bash-completion executable: Generates Bash completion for an _executable_ supporting ${NAME}.
				@document format(pdf|manpage|markdown|grofftty): Generates document on the standard output according to the given _format_.
			_EOF_
			init
		)
		declare -x ADS_INITILIZED=true
		__init ${@:2}
		_argc=$?
		case ${ADS_DEBUG:-false} in
			verbose|true) exec {stdoutbck}>&1 1>&2;;
		esac
		${@:1:1} ${@:${_argc}+2}
	fi
}

init() {
	local _name _cmd _opt
	local ADS_CMD_PFX=
	local ADS_OPT_PFX=

	while [ $# -ne 0 ]; do
		case "$1" in
			--prefix)     ADS_CMD_PFX=${2^^}_; ADS_OPT_PFX=${2^^}_; shift;;
			--opt-prefix) ADS_OPT_PFX=${2^^}_; shift;;
			--cmd-prefix) ADS_CMD_PFX=${2^^}_; shift;;
			--)           shift; break;;
			 *)           break;;
		esac
		shift
	done
	if ${ADS_INITILIZED:-false}; then
		case ${ADS_DEBUG:-false} in
			verbose) set -x;&
			true)    for _cmd in ${ADS_CMDID[@]}; do
			         	__debug_command ${ADS_CMD[${_cmd}]}
			         done;;
		esac
	fi

	declare -ga ADS_ARGV=($@)
	__parse_cmdline \
		--cmdline-pre-hook  __pre_init \
		--cmdline-post-hook __post_init \
		--cmd-post-hook     __cmd_init \
		--opt-hook          __opt_init \
		--cmd-error-hook    __cmd_error \
		--opt-error-hook    __opt_error \
		-- $@
	return $?
}

__usage() {
	local _msg _cmd
	while [ $# -ne 0 ]; do
		case "$1" in
			--command|-c) shift; _cmd=$1 ;;
			--)           shift; break;;
			 *)           break;;
		esac
		shift
	done

	if (( ${#@} > 0 )); then
		_msg=$(echo "$@"|__filter_input|__man_inline_style)$'\n.SH Usage:'
	else
		_msg='.SH Usage: '
	fi
	groff -Kutf8 -Tutf8 -man <<-EOF | sed '/^\s*$/d;/\s*()/d;/()\s*()/d'
		.TH
		${_msg}
		$(__synopsys ${_cmd})
	EOF
}

bash-completion() {
	local _command=$1
	cat - <<-EOF
		_${_command// /-}_bash_completion() {
			local completion='$(__parse_cmdline --cmd-post-hook __bash_completion_commands --opt-hook __bash_completion_options)'
			local -A options

			for i in \$(seq 0 \$COMP_CWORD); do
				case "\${COMP_WORDS[\$i]}" in
					$(__parse_cmdline --cmd-post-hook __bash_completion_command --opt-hook __bash_completion_option)
				esac
			done
			COMPREPLY=( \$(compgen -o nospace -W "\${completion//  / }" -- \${COMP_WORDS[COMP_CWORD]}) )
			case "\${COMP_WORDS[COMP_CWORD - 1]}" in
				$(__parse_cmdline --opt-hook __bash_completion_value)
			esac
		}
		complete -F "_${_command// /-}_bash_completion" "${_command}" $@
	EOF
}

__parse_cmdline() {
	local _cmdline_pre_hook _cmdline_post_hook _cmd_pre_hook _cmd_post_hook _opt_hook
	local _i _argc _argv _id _varname _cmdid _cmd _opt _command _found

	while [ $# -ne 0 ]; do
		case "$1" in
			--cmd-pre-hook)      _cmd_pre_hook=$2; shift;;
			--cmd-post-hook)     _cmd_post_hook=$2; shift;;
			--cmdline-pre-hook)  _cmdline_pre_hook=$2; shift;;
			--cmdline-post-hook) _cmdline_post_hook=$2; shift;;
			--opt-hook)          _opt_hook=$2; shift;;
			--cmd-error-hook)    _cmd_error_hook=$2; shift;;
			--opt-error-hook)    _opt_error_hook=$2; shift;;
			--)                  shift; break;;
			 *)                  break;;
		esac
		shift
	done
	_argc=$#

	if declare -F "${_cmdline_pre_hook}" &>/dev/null; then
		${_cmdline_pre_hook}
	fi
	local -n _cmd=ADS_CMD_0
	while [ $# -ne 0 ]; do
		if [[ $1 = -- ]]; then
			shift
			break
		fi
		if [[ $1 =~ ^- ]]; then
			# Option
			local _alias _optname _found=false
			for _id in ${_cmd[options]}; do
				local -n _opt=${ADS_OPT[${_id%%|*}]}
				case $1 in
					--?*)  _optname=${1:2};;
					-[^-]) _optname=${1:1};;
					--)    shift; continue;;
				esac
				for _alias in ${_opt[name]} ${_opt[alias]//|/ }; do
					if [[ ${_optname} == ${_alias} ]]; then
						if (( ${#_opt[value]} == 0 )); then
							_opt=true
						else
							_opt=$2
							shift
						fi
						_found=true
						break
					fi
				done
			done
			if ! $_found && declare -F "${_opt_error_hook}" &>/dev/null; then
				${_opt_error_hook} "${_cmdid}" "$1"
			fi
		else
			# Command
			_id=$(__join . ${_cmdid} $1)
			_varname=${ADS_CMD[${_id}]}
			if declare -p "${_varname}" &>/dev/null; then
				local -n _cmd=${ADS_CMD[${_id}]}
				_cmdid=${_id}
				shift
				if (( ${#_cmd[value]} == 0 ));then
					_cmd=true
				else
					let _i=0
					until [ $# -eq 0 ] || [[ $1 =~ ^-.$ ]] || [[ $1 =~ ^--[^-].*$ ]]; do
						_cmd[0]+="\$'${1//\'/\\\'}' "
						shift
					done
				fi
				continue
			elif declare -F "${_cmd_error_hook}" &>/dev/null; then
				${_cmd_error_hook} "${_id}"
			fi
		fi

		shift
	done
	local -n _command=${!_cmd}

	for _id in ${ADS_CMDID[@]}; do
		local -n _cmd=${ADS_CMD[${_id}]}
		if declare -F "${_cmd_pre_hook}" &>/dev/null; then
			${_cmd_pre_hook} ${!_cmd}
		fi
			for _id in ${_cmd[options]}; do
				local -n _opt=${ADS_OPT[${_id%%|*}]}
				if (( ${#_opt[value]} == 0 )) && (( ${#_opt} == 0 )); then
					_opt=false
				fi
				if declare -F "${_opt_hook}" &>/dev/null; then
					${_opt_hook} ${!_opt} ${!_command}
				fi
			done
		if declare -F "${_cmd_post_hook}" &>/dev/null; then
			${_cmd_post_hook} ${!_cmd}
		fi
	done

	let _argc=${_argc}-$#
	if declare -F "${_cmdline_post_hook}" &>/dev/null; then
		if declare -p "${!_command}" &>/dev/null; then
			${_cmdline_post_hook} ${!_command}
		else
			${_cmdline_post_hook} ${ADS_CMD} ${_argc}
		fi
	fi
	return $_argc
}

__join() {
	local _sep=$1; shift
	local _string=$1; shift
	while [ $# -ne 0 ]; do
		_string+=${_sep}$1
		shift
	done
	echo ${_string}
}

__pre_init() {
	cat - <<-EOF
		__ads_heredoc() {
			cat - <<-_BEOF_
				${ADS_INPUT}
			_BEOF_
		}

		${ADS_CMD_PFX,,}usage() {
			local _msg
			local errno=1
			while [ \$# -ne 0 ]; do
				case "\$1" in
					--errno)      errno=\$2; shift;;
					--)           shift; break;;
					 *)           break;;
				esac
				shift
			done
			__ads_heredoc|"\$0" __ads__ usage -- ${ADS_NAME,,}: \$@ >/dev/\$( [ "\${errno}" = 0 ] && echo stdout || echo stderr)
			exit \${errno}
		}
	EOF
}

__cmd_init() {
	true
}

__check_value() {
	local _element_type=$1
	local _element_id=$2
	local _value=$3
	local _constraint=$4

	case ${_constraint} in
		'') ;;
		/*/) [[ -d $_v ]] || {
			echo "Directory for ${_element_type} '${_element_id//./ }' must exists." >&2
			echo exit 1
			exit 0
		} ;;
		/*) [[ -r $_value ]] || {
			echo "File for ${_element_type} '${_element_id//./ }' must exists and be readable." >&2
			echo exit 1
			exit 0
		} ;;
		*) [[ ${_value} =~ ^${_constraint}$ ]] || {
			echo "Value for ${_element_type} '${_element_id//./ }' must match ^$_constraint$." >&2
			echo exit 1
			exit 0
		} ;;
	esac
}

__post_init() {
	local -n _cmd=$1
	local _shift=$2
	local _k _v _key_name _key_constraint _value_name _value_constraint
	local _varname=${_cmd[id]^^}
	if [[ ${!_cmd} == ADS_CMD_0 ]]; then
		_varname=${ADS_OPT_PFX}_0
	else
		_varname=${ADS_OPT_PFX}${_varname//[.-]/_}
	fi
	eval local -a _value=($_cmd)

	#                        key=value
	#                        key(key constraint)=value(value constraint)
	#                        1       2  3        4       5  6
	if [[ ${_cmd[value]} =~ ^([^\(]*)(\((.+)\))?=([^\(]*)(\((.+)\))?$ ]]; then
		_key_name=${BASH_REMATCH[1]}
		_key_constraint=${BASH_REMATCH[3]}
		_value_name=${BASH_REMATCH[4]}
		_value_constraint=${BASH_REMATCH[6]}
	#                          value
	#                          value(value constraint)
	#                          1      2   3
	elif [[ ${_cmd[value]} =~ ^([^\(]+)(\((.+)\))?$ ]]; then
		_value_name=${BASH_REMATCH[1]}
		_value_constraint=${BASH_REMATCH[3]}
	fi

	if (( ${#_value} == 0 )) && (( ${#_key_name} == 0 )); then
		case ${_cmd[value]} in
			/*/) _value[0]=./ ;;
			/*)  _value[0]=-;;
		esac
	fi

	_cmd=
	for _v in ${_value[@]}; do
		if (( ${#_key_name} > 0 )); then # Associative array
			_k=${_v%%=*}
			_v=${_v#*=}
			if (( ${#_key_constraint} > 0 )); then
				__check_value "command '${_cmd[id]//./ }' parameter name" "${_key_name}" "$_k" "${_key_constraint}"
			fi
		fi
		if [[ ${_v} =~ ^-$|^$ ]]; then
			case ${_cmd[value]} in
				/*/) ${_cmd[requiered]} || _v=./ ;;
				/*)  ${_cmd[requiered]} && _v=/dev/stdin || _v=/dev/stdout ;;
			esac
		fi
		if (( ${#_key_name} > 0 )); then # Associative array
			_cmd[0]+="[\$'${_k//\'/\\\'}']=\$'${_v//\'/\\\'}' "
		else
			_cmd[0]+="\$'${_v//\'/\\\'}' "
		fi
		if (( ${#_value_constraint} > 0 )); then
			__check_value "command '${_cmd[id]//./ }' parameter value" "${_value_name}" "$_v" "${_value_constraint}"
		fi
	done

	if ${_cmd[multi]} && ${_cmd[requiered]} && (( ${#_value[@]} == 0 )); then
		echo "There must be at least one value for command '${_cmd[id]//./ }'" >&2
		echo exit 1
		exit 0
	elif ${_cmd[requiered]} && (( ${#_value[@]} == 0 )); then
		echo "There must be a value for command '${_cmd[id]//./ }'" >&2
		echo exit 1
		exit 0
	elif ! ${_cmd[multi]} && (( ${#_value[@]} > 1 )); then
		echo "There must be only one value for command '${_cmd[id]//./ }'" >&2
		echo exit 1
		exit 0
	fi

	if (( ${#_key_name} > 0 )); then # Associative array
		echo "declare -gA ${_varname}=(${_cmd})"
	elif ${_cmd[multi]}; then
		echo "declare -ga ${_varname}=(${_cmd})"
	else
		echo "declare -g ${_varname}=${_cmd}"
	fi

	if [[ ${_cmd[id]} == bash-complete ]] && [[ ${ADS_NAME} =~ ^(AETEN_)?ADS$ ]]; then
		__add_command ads.bash-complete "Bash completion auto generation from _ADS_."
	fi
	if ${ADS_OPT_HELP:-false}; then
		__help
	else
		cat - <<-EOF
			declare -g ADS_CMD=${_cmd[id]}
			shift $_argc
		EOF
	fi
}

__opt_init() {
	local -n _opt=$1
	local -n _selected_cmd=$2
	local _varname=${_opt[id]^^}
	_varname=${ADS_OPT_PFX}${_varname//[.-]/_}
	if (( ${#_opt} > 0 )); then
		echo "declare -g ${_varname}='${_opt}'"
		case ${_opt[value]} in
			!/*/) [[ -d $_opt ]] || {
				echo Directory for option --${_opt[name]} must exists. >&2
				echo exit 1
			} ;;
			!/*)  [[ -r $_opt ]] || {
				echo File for option --${_opt[name]} must exists and be readable. >&2
				echo exit 1
			} ;;
			*\|*) [[ ${_opt} =~ ^${_opt[value]}$ ]] || {
				echo Value for option --${_opt[name]} must be one of ${_opt[value]}. >&2
				echo exit 1
			} ;;
		esac
	elif [[ ${_opt[command]} == ${_selected_cmd[id]} ]] && ${_opt[requiered]}; then
		__usage --command ${_selected_cmd[id]} "Option --${_opt[name]} is requiered." >&2
		echo exit 1
	fi
}

__cmd_error() {
	local _cmd=${ADS_CMD_0[name]}.$1
	local _out=/proc/$(ps -p $PPID -o ppid=)/fd/1 # Grandpa
	_out=${_out// /}
	_cmd=${_cmd%.*}
	case $1 in
		__ads__) _cmdid=$1;;
		__ads__.usage)    echo exit 0; __usage ${ADS_ARGV[@]:2} >${_out};;
		__ads__.grofftty) echo exit 0; __groff | groff -Kutf8 -Tutf8 -man - >${_out};;
		__ads__.pdf)      echo exit 0; __groff | groff -Kutf8 -Tpdf -man - >${_out};;
		__ads__.man)      echo exit 0; __groff >${_out};;
		__ads__.markdown) echo exit 0; __groff | preconv -eutf8 | pandoc -f man -t commonmark | sed 's/\\\\f[IR]/_/g' >${_out};;
		__ads__.bash-completion) echo exit 0; __ads_heredoc|bash-completion;;
		*)
			__usage --command "${1%.*}\..*" "${ADS_CMD_0[name]}: '${1##*.}' is not a '${_cmd//./ }' command. See '${ADS_CMD_0[name]} --help'." >&2
			echo exit 1
			exit 0
		;;
	esac
}

__opt_error() {
	local _cmd=$1 _opt=$2
	__usage --command "${_cmd}(\..*)?" "${ADS_CMD_0[name]}: '${_opt}' is not a ${ADS_CMD_0[name]} ${_cmd//./ } option. See '${ADS_CMD_0[name]} --help'." >&2
	echo exit 1
	exit 0
}

__synopsys_man() {
	local _value _standard=true
	if [[ $1 = --no-standard ]]; then
		_standard=false
		shift
	fi
	local -n _opt=$1
	_value=${_opt[value]}
	#                        key=value
	#                        key(key constraint)=value(value constraint)
	#                        1       2  3        4       5  6
	if [[ ${_opt[value]} =~ ^([^\(]*)(\((.*)\))?=([^\(]*)(\((.*)\))?$ ]]; then
		_value=${BASH_REMATCH[1]}=${BASH_REMATCH[4]}
	#                          value
	#                          value(value constraint)
	#                          1      2  3
	elif [[ ${_opt[value]} =~ ^([^(]+)(\(([^)]+)\))?$ ]]; then
		_value=${BASH_REMATCH[1]}
	fi

	_value=${_value#/}
	_value=${_value#\!/}
	_value=${_value%/}
#	if ${_standard}; then
#		if ${_opt[requiered]}; then
#			printf '.B -%s\\fR|\\fB--%s\n%s\n' ${_opt[alias]%%|*} ${_opt[name]} "$([ -n "${_value}" ] && echo ".I ${_value}")"
#		else
#			printf '.OP \-%s\\fR|\\fB--%s%s\n' ${_opt[alias]%%|*} ${_opt[name]} "$([ -n "${_value}" ] && echo " ${_value}")"
#		fi
#	else
		if ${_opt[requiered]}; then
			printf '\\fB-%s\\fR|\\fB--%s %s\\fR\\ ' ${_opt[alias]%%|*} ${_opt[name]} "$([ -n "${_value}" ] && echo " \\fI${_value}")"
		else
			printf '\\fR[\\fB-%s\\fR|\\fB--%s\\fR%s\\fR]\\ ' ${_opt[alias]%%|*} ${_opt[name]} "$([ -n "${_value}" ] && echo " \\fI${_value}")"
		fi
#	fi
}

__man_opt() {
	local -n _opt=$1
	local _value _formated_value
	_value=${_opt[value]}
	if [ -n "${_value}" ]; then
		_value=${_value#/}
		_value=${_value#\!/}
		_value=${_value%/}

		formated_value="\\ \\fI${_value}"
	fi
	cat - <<-EOF
		.TP
		\\fB\\-\\-${_opt[name]}\\fR${formated_value}\\fR, \\fB\\-${_opt[alias]}\\fR ${formated_value}
		\\fR$(echo "${_opt[description]}"|__man_inline_style)
		.sp
	EOF
}

__man_inline_style() {
	sed --regexp-extended 's/\\n/\n.br\n/g; s/\\_/\\(ul/g; s/\\\*/\\[u0042]/g; s/([^\]?)_([^_]+)_( )?/\1\\fI\2\\fR\3/g;s/([^\\])?\*([^*]+)\*( )?/\1\\fB\2\\fR\3/g; s/ /\\[u00A0]/g; s/\\\[u0042\]/*/g; s/  / \\ /g'
}

__help() {
	__groff|man -l - >&2
	echo exit 0
}

__synopsys() {
	local _id _value _cmdid=$1
	echo ".SY ${ADS_CMD_0[name]}"
	for _id in ${ADS_CMD_0[options]}; do
		__synopsys_man ${ADS_OPT[${_id%%|*}]}
	done
	if (( ${#ADS_CMDID[@]} > 1 )); then
		echo -n "\\fIcommand\\fR [\\fIargs\\fR]"
		for _id in ${ADS_CMDID[@]:1}; do
			if (( ${#_cmdid} > 0 )) && [[ ! ${_id} =~ ^${_cmdid}$ ]]; then
				continue
			fi
			local -n _cmd=${ADS_CMD[${_id}]}
			if [[ ${_cmd[description]} =~ ^\ *-\ *$ ]]; then
				continue
			fi
			echo -n $'\n'".SY ${ADS_CMD_0[name]}\\ ${_cmd[id]//./\\ }"
			if (( ${#_cmd[options]} > 0 )) || (( ${#_cmd[value]} > 0 )); then
				echo
			fi
			for _id in ${_cmd[options]}; do
				__synopsys_man ${ADS_OPT[${_id%%|*}]}
			done
			#                        key=value
			#                        key(key constraint)=value(value constraint)
			#                        1      2  3        4      5  6
			if [[ ${_cmd[value]} =~ ^([^\(]*)(\((.*)\))?=([^\(]*)(\((.*)\))?$ ]]; then
				_value=${BASH_REMATCH[4]#/}
				_value=${_value#\!/}
				_value=${_value%/}
				echo -n "\\fI${BASH_REMATCH[1]}\\fR=\\fI${_value}\\fR"
			#                          value
			#                          value(value constraint)
			#                          1      2  3
			elif [[ ${_cmd[value]} =~ ^([^(]+)(\(([^)]+)\))?$ ]]; then
				_value=${BASH_REMATCH[1]#/}
				_value=${_value#\!/}
				_value=${_value%/}
				echo -n "\\fI${_value}\\fR"
			fi
		done
	fi
}

__groff() {
	local _cmd _id _value
	cat - <<-EOF
		.TH ${ADS_CMD_0[name]^^} 1 "$(date +%D)" "${ADS_CMD_0[name]^^} ${ADS_CMD_0[version]}" "${ADS_CMD_0[title]}"
		.ie \n(.g .ds Aq \(aq
		.el       .ds Aq '
		.nh
		.ad l
		.SH NAME
		.NH 1 ${ADS_CMD_0[name]}
		.PP
		${ADS_CMD_0[name]} - $(echo "${ADS_CMD_0[resume]}"|__man_inline_style)
		.SH SYNOPSYS
		.
		$(__synopsys)
		.fi
		.sp
		.SH DESCRIPTION
		$(echo "${ADS_CMD_0[description]}"|__man_inline_style)
		.sp
		$(if (( ${#ADS_CMDID[@]} > 1 )); then
			echo -e '.SH COMMANDS\n.'
			for _id in ${ADS_CMDID[@]:1}; do
				local -n _cmd=${ADS_CMD[${_id}]}
				if [[ ${_cmd[description]} =~ ^\ *-\ *$ ]]; then
					continue
				fi
				echo -en ".SS \\\fB ${ADS_CMD_0[name]}\\ ${_cmd[id]//./\\ } "
				for _id in ${_cmd[options]}; do
					 __synopsys_man --no-standard ${ADS_OPT[${_id%%|*}]}
				done
				#                        key=value
				#                        key(key constraint)=value(value constraint)
				#                        1      2  3        4       5  6
				if [[ ${_cmd[value]} =~ ^([^\(]*)(\((.*)\))?=([^\(]*)(\((.*)\))?$ ]]; then
					echo "\\fI${BASH_REMATCH[1]}\\fR=\\fI${BASH_REMATCH[4]}\\fR"
				#                          value
				#                          value(value constraint)
				#                          1      2  3
				elif [[ ${_cmd[value]} =~ ^([^(]+)(\(([^)]+)\))?$ ]]; then
					_value=${BASH_REMATCH[1]#/}
					_value=${_value#\!/}
					_value=${_value%/}
					echo "\\fI${_value}\\fR"
				fi
				echo $'\n.fi\n.'
				#                        key=value
				#                        key(key constraint)=value(value constraint)
				#                        1       2  3        4       5  6
				if [[ ${_cmd[value]} =~ ^([^\(]*)(\((.*)\))?=([^\(]*)(\((.*)\))?$ ]]; then
					if (( ${#BASH_REMATCH[3]} > 0 )); then
						echo "\\fI${BASH_REMATCH[1]}\\fR = ${BASH_REMATCH[3]}"
						echo $'\n.fi\n.'
					fi
					if (( ${#BASH_REMATCH[6]} > 0 )); then
						echo "\\fI${BASH_REMATCH[4]}\\fR = ${BASH_REMATCH[6]}"
						echo $'\n.fi\n.'
					fi
				#                          value
				#                          value(value constraint)
				#                          1      2  3
				elif [[ ${_cmd[value]} =~ ^([^(]+)(\(([^)]+)\))?$ ]]; then
					if (( ${#BASH_REMATCH[3]} > 0 )); then
						echo $'\n.fi\n.'
						echo "\\fI${BASH_REMATCH[1]}\\fR = ${BASH_REMATCH[3]}"
						echo $'\n.fi\n.'
					fi
				fi
				echo "${_cmd[description]}"|__man_inline_style
				for _id in ${_cmd[options]}; do
					__man_opt ${ADS_OPT[${_id%%|*}]}
				done
			echo .sp
			done
			echo .sp
		fi)
		.SH OPTIONS
		$(for _id in ${ADS_CMD_0[options]}; do
			__man_opt ${ADS_OPT[${_id%%|*}]}
		done)
		$(test -n "${_cmd[author]}" && { echo .sp; echo .SH AUTHOR; echo "${_cmd[author]}"; })
		$(test -n "${_cmd[authors]}" && { echo .sp; echo .SH AUTHORS; echo "${_cmd[authors]}"; })
		$(test -n "${_cmd[copyright]}" && { echo .sp; echo .SH COPYRIGHT; echo "© ${_cmd[copyright]}"; })
		$(test -n "${_cmd[copyleft]}" && { echo .sp; echo .SH COPYLEFT; echo "🄯 ${_cmd[copyleft]}"; })
		$(test -n "${_cmd[licence]}" && { echo .sp; echo .SH LICENCE; echo "${_cmd[licence]}"; })
		$(test -n "${_cmd[license]}" && { echo .sp; echo .SH LICENCE; echo "${_cmd[license]}"; })
	EOF
}

__bash_completion_options() {
	local -n _opt=$1
	echo -n "--${_opt[name]} "
}

__bash_completion_commands() {
	local -n _cmd=$1
	echo -n "${_cmd[name]} "
}

__bash_completion_option() {
	local -n _opt=$1
	${_opt[multi]} && return;
	cat - <<-EOF
		"-${_opt[alias]%%|*} "|"--${_opt[name]} ")
			completion=\${completion/--${_opt[name]} /}
	EOF
	if [ -z "${_opt[value]}" ]; then
		cat - <<-EOF
			options+=${_opt[alias]%%|*}
		EOF
	else
		cat - <<-EOF
			[ -n \"\${COMP_WORDS[\$i + 1]}\" ] && options+=${_opt[alias]%%|*}
		EOF
	fi
	cat - <<-EOF
		;;
	EOF
}

__bash_completion_command() {
	local -n _cmd=$1
	${_opt[multi]} && return;
	cat - <<-EOF
		"${_cmd[name]} ")
			completion=\${completion/${_cmd[name]} /}
			;;
	EOF
}

__add_command() {
	local _id=$1
	local _description=$2

	local _name=${_id##*.}
	local _varname=${_id^^}
	_varname=ADS_OPT_${_varname//[.-]/_}
	declare -gA ${_varname}
	local -n _cmd=${_varname}
	_cmd=(
		[0]=
		[id]=${_id}
		[name]=${_name}
		[value]=
		[requiered]=false
		[multi]=false
		[description]=${_description}
		[options]=
	)
	ADS_CMDID+=(${_id})
	ADS_CMD[${_id}]=${_varname}
}

__add_help() {
	local -n _cmd=$1

	local _optname=$(__join _ ${_cmd[id]^^} HELP)
	_optname=ADS_OPT_${_optname//[.-]/_}
	declare -gA ${_optname}
	local -n _option=${_optname}
	_option[0]=
	_option[id]=$(__join . ${_cmd[id]} help)
	_option[name]=help
	_option[alias]=h
	_option[value]=
	_option[command]=${_cmd[id]}
	_option[requiered]=false
	_option[multi]=false
	_option[description]="Print _${_cmd[name]}_ help."
	ADS_OPT[${_option[id]}]=${_optname}
	_cmd[options]+=" ${_option[id]}|h"
}

__filter_input() {
	sed 's/\\\([^_]\|$\)/\\e\1/g
		s/  / \\ /g
		s/'"'"'/\\[u0027]/g
		s/"/\\[u0022]/g
		s/`/\\[u0060]/g
		s/\$/\\[u0024]/g
	'
}

__init() {
	local _argc=$#
	local  _opt _option_level _option_command _command _option _COMMAND _OPTION _option2 _OPTION2 _requiered _multi _occurence _name _alias _ads_name
	local -n _cmd
	local _spaces=$'[ \t]'
	local -i _level=0
	local IFS

	while [ $# -ne 0 ]; do
		case "$1" in
			 -)           ADS_INPUT_FILE=/dev/stdin;;
			 --)          shift; break;;
			 *)           break;;
		esac
		shift
	done

	declare -gr ADS=$(basename $(readlink -f ${0}))
	if [[ ${ADS} =~ ^(aeten-)?ads$ ]]; then
		_name=$(basename $(ps -p $PPID -o comm=))
	else
		_name=${ADS}
	fi

	declare -gr ADS_CALLER=${_name}
	_name=${_name^^}
	_name=${_name//[. ]/_}

	declare -gr ADS_NAME=${_name//-/_}
	declare -gr ADS_INPUT=$(sed 's/^ \+//' ${ADS_INPUT_FILE:-/dev/stdin}|__filter_input)
	declare -gA ADS_OPT
	declare -ga ADS_CMDID=(0)
	declare -gA ADS_CMD=([${ADS_CMDID}]=ADS_CMD_0)
	declare -gA ADS_CMD_0=(
		[0]=
		[id]=
		[name]="${ADS_CALLER}"
		[value]=
		[requiered]=false
		[multi]=false
		[description]=
		[options]=
	)
	__add_help ${ADS_CMD[${ADS_CMDID}]}

	IFS=$'\n'
	for _opt in ${ADS_INPUT}; do
		unset ISF
		[ -z "${_opt}" ] && continue
		if [[ ${_opt} =~ ^$'\t'* ]]; then
			_option_level=${#BASH_REMATCH[0]}
		else # Should not occure
			continue
		fi
		if [[ ${_opt} =~ ^#([a-zA-Z0-9-]+)${_spaces}*:(${_spaces}+\\${_spaces}+)*${_spaces}*([^ ].*) ]]; then
			ADS_CMD_0[${BASH_REMATCH[1],,}]=${BASH_REMATCH[3]}
		elif [[ ${_opt} =~ ^($'\t'{$_option_level})@([a-zA-Z0-9-]+)(${_spaces}+([!+*?]?)([][()=|_/a-zA-Z0-9.+*!?\\^\$-]+))?:(${_spaces}+\\${_spaces}+)*${_spaces}*([^ ].*) ]]; then
			if ((${_option_level} == 0)); then
				_option_command=${BASH_REMATCH[2]}
			elif ((${_option_level} > ${_level})); then
				_option_command=${_command}.${BASH_REMATCH[2]}
			else
				_command=${_command%.*}
				until ((${_option_level} == ${_level})); do
					command=${_command%.*}
					let _level--
				done
				_option_command=${_command}.${BASH_REMATCH[2]}
			fi
			_level=${_option_level}
			_command=${_option_command}
			_description=${BASH_REMATCH[7]}
			_occurence=${BASH_REMATCH[4]}
			case "${_occurence}" in
				''|'?') _requiered=false; _multi=false;;
				   '*') _requiered=false; _multi=true;;
				   '+') _requiered=true;  _multi=true;;
				   '!') _requiered=true;  _multi=false;;
			esac
			_COMMAND=ADS_CMD_${_command^^}
			_COMMAND=${_COMMAND//[.-]/_}
			ADS_CMDID+=(${_command})
			ADS_CMD[${_command}]=${_COMMAND}
			declare -gA ${_COMMAND}
			local -n _CMD=${_COMMAND}
			_CMD=(
				[id]=${_command}
				[name]=${BASH_REMATCH[2]}
				[value]=${BASH_REMATCH[5]}
				[requiered]=${_requiered}
				[multi]=${_multi}
				[description]=${BASH_REMATCH[7]}
				[options]=
			)
		elif (( ${_option_level} == 0 )); then
			_option_command=
			_command=
			_level=0
		elif ((${_option_level} > ${_level})); then
			_option_command=
			_level=$((${_option_level}-1))
		else
			_option_command=
			_command=${_command%.*}
			until ((${_option_level} == ${_level})); do
				_command=${_command%.*}
				let _level--
			done
			let _level--
		fi
		if [[ ${_opt} =~ ^${_spaces}*([!+*?]?)([a-zA-Z0-9-]+)(\|([a-zA-Z0-9]))?(${_spaces}+([!:|@_/a-zA-Z0-9-]+))?:(${_spaces}+\\${_spaces}+)*${_spaces}*([^ ].*) ]]; then
			_option=$(__join . ${_command} ${BASH_REMATCH[2]})
			_OPTION=${_option^^}
			_OPTION=ADS_OPT_${_OPTION//[.-]/_}
			_occurence=${BASH_REMATCH[1]}
			case "${_occurence}" in
				''|'?') _requiered=false; _multi=false;;
				   '*') _requiered=false; _multi=true;;
				   '+') _requiered=true;  _multi=true;;
				   '!') _requiered=true;  _multi=false;;
			esac
			_name=${BASH_REMATCH[2]}
			_alias=${BASH_REMATCH[4]}
			((${#_alias} == 0)) && _alias=${_name:0:1}
			if ((${#_command} == 0)); then
				_COMMAND=ADS_CMD_0
			else
				_COMMAND=${_command^^}
				_COMMAND=ADS_CMD_${_COMMAND//[.-]/_}
			fi
			declare -gA ${_OPTION}
			local -n _OPT=${_OPTION}
			_OPT=(
				[0]=
				[id]=${_option}
				[name]=${_name}
				[alias]=${_alias}
				[value]=${BASH_REMATCH[6]}
				[command]=${_command}
				[requiered]=${_requiered}
				[multi]=${_multi}
				[description]=${BASH_REMATCH[8]}
			)
			local -n _CMD=${_COMMAND}
			_CMD[options]+=" ${_option}|${_alias}"
			ADS_OPT[${_option}]=${_OPTION}
			# Add alias 
			_option2=$(__join . ${_command} ${_alias})
			_OPTION2=ADS_OPT[${_option2}]
			if ! declare -p "${!_OPTION2}" >& /dev/null; then
				ADS_OPT[${_option}]=${_OPTION}
			elif [[ ${DEBUG} = yes ]]; then
				echo "[WARNING] While processing option alias ${_alias} for option ${_alias} (already taken by ${_OPTION2[id]})" >&2
			fi
		fi
	done
	let _argc-=$#
	return $_argc
}

__bash_completion_value() {
	# /* file
	# /*/ directory
	# | separates a choice
	cat - <<-EOF
		-${short}|--${option})
		if [ "\$(type -t "_${cmd}_bash_complete_${option}")" = function ]; then
			_${cmd}_bash_complete_${option}
		else
	EOF
	if [ -n "${value}" ] && [ -z "${value%/*/}" ]; then
		cat - <<-EOF
			# Directory
			compopt -o nospace
			COMPREPLY=( \$(compgen -W "\$([ -d "\${COMP_WORDS[COMP_CWORD]}" ] && find \${COMP_WORDS[COMP_CWORD]}* -maxdepth 0 -type d -printf '%p/\n' 2>/dev/null || find \${COMP_WORDS[COMP_CWORD]}* -maxdepth 0 -type d -printf '%p/\n' 2>/dev/null)" -- \${COMP_WORDS[COMP_CWORD]}) )
		EOF
	elif [ -n "${value}" ] && [ -z "${value%/*}" ]; then
		cat - <<-EOF
			# File
			compopt -o nospace
			COMPREPLY=( \$(compgen -W "\$(find \${COMP_WORDS[COMP_CWORD]}* -maxdepth 0 \( -type d -printf '%p/ ' , -type f -print \) 2>/dev/null)" -- \${COMP_WORDS[COMP_CWORD]}) )
		EOF
	elif [ -n "${value}" ] && [ -z "${value##*|*}" ]; then
		cat - <<-EOF
			# Choice
			COMPREPLY=( \$(compgen -W "${value//|/ }" -- \${COMP_WORDS[COMP_CWORD]} ) )
		EOF
	else
		cat - <<-EOF
			# Other
			true
		EOF
	fi
	cat - <<-EOF
			fi
			;;
	EOF
}

__debug_command() {
	local -n _command=$1
	local _opt _occurence _value

	if (( ${#_command[value]} > 0 )); then
		if   ${_command[requiered]} && ${_opt[multi]}; then _occurence=+
		elif ${_command[requiered]};                   then _occurence=!
		elif ${_command[multi]};                       then _occurence=*
		else                                                _occurence=?
		fi
		_value=" ${_occurence}${_command[value]}"
	fi
	echo "${_command[id]}${_value}: ${_command[description]}" >&2
	for _opt in ${_command[options]}; do
		__debug_option ${ADS_OPT[${_opt%%|*}]}
	done
}

__debug_option() {
	local -n _opt=$1
	local _occurence _value

	if   ${_opt[requiered]} && ${_opt[multi]}; then _occurence=+
	elif ${_opt[requiered]};                   then _occurence=!
	elif ${_opt[multi]};                       then _occurence=*
	else                                            _occurence=?
	fi
	if ((${#_opt[value]} > 0)); then
		_value=\ ${_opt[value]}
	fi

	echo "${_occurence}${_opt[id]}|${_opt[alias]}${_value}: ${_opt[description]}" >&2
}

__api() {
	sed --quiet --regexp-extended 's/^([[:alpha:]][[:alnum:]_-]+)\s*\(\)\s*\{/\1/p' "${*}" 2>/dev/null
}

__is_api() {
	test 1 -eq $(__api "${1}"|grep "^${2}$"|wc -l) 2>/dev/null
}

__init__ $@
